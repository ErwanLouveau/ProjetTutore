---
title: "Projet tutoré v1"
author: "Mathilda Alhamadah"
date: "2024-01-17"
output: html_document
---


```{r Graphe scores et individus}
library(tidyverse)
library(DynForest)
library(fdapace)
library(JM)
library(fda)

#test avec cw

data("CanadianWeather")
data<- CanadianWeather

acpf_data <- acpf(data, donnees = "dailyAv", variable = "Temperature.C", type="denseList")

#scores = xiest*phi+mu
data_scores <- acpf_data$xiEst %*% t(acpf_data$phi) + matrix(rep(acpf_data$mu, times = 35), nrow = 35, byrow = TRUE) 

# Data
selected_indiv = 1 #on choisit d'afficher l'individu 1 et son score (ici c'est St.Johns=le 1er individu)

a=c(1:nrow(as.data.frame(data$dailyAv[, 1, "Temperature.C"])))  #ici nous c'est 365 individus
b=data_scores[selected_indiv,]    #on veut afficher l'individu sélectionné par l'utilisateur
c=data$dailyAv[, selected_indiv, "Temperature.C"]

# Graphe
plot( b~a ,
      type="l" ,
      bty="l" ,
      xlab="time" ,
      ylab="variable y" , col=rgb(0.2,0.4,0.1,0.7) ,
      lwd=3 ,
      ylim=c(min(data$dailyAv[, , "Temperature.C"]),max(data$dailyAv[, , "Temperature.C"])) ) #ylim = les valeurs min et max pour cett var pour TOUS les indivs
lines(c ~a , col=rgb(0.8,0.4,0.1,0.7) , lwd=3 , pch=19 , type="l" )

# Legend
legend("bottomleft", 
       legend = c("model estimation (score)", "original data"), 
       col = c(rgb(0.2,0.4,0.1,0.7), 
               rgb(0.8,0.4,0.1,0.7)), 
       lty=1, 
       bty = "n", 
       pt.cex = 2, 
       cex = 1.2, 
       text.col = "black", 
       horiz = F , 
       inset = c(0.1, 0.1))

#fonction paste 0("individu", var) pour avoir titres dynamiques
#rajouter des CP et/ou mettre la possibilité de mettre un nbmin de cp

#fonction d'ERwan : pouvoir fixer le threshold ou le nb de CP (plutôt threshold + facile)

```

```{r Graphe contribution de chaque CP à la projection d'un indiv}
acpf_cw_temperature <- acpf(CanadianWeather, donnees = "dailyAv", variable = "Temperature.C", type="denseList")

#scores = xiest*phi+mu
cw_scores <- acpf_cw_temperature$xiEst %*% t(acpf_cw_temperature$phi) + matrix(rep(acpf_cw_temperature$mu, times = 35), nrow = 35, byrow = TRUE) 

# Paramètres utilisateur
selected_indiv = 7
nbmaxcp = 3

# Données
test2 <- data.frame(
  name = paste("CP", seq_len(ncol(acpf_cw_temperature$xiEst)), sep = "") ,  #noms des CP
  value = acpf_cw_temperature$xiEst[selected_indiv,]              #les 4 col pour l'indiv sélectionné
  )

# Barplot
ggplot(test2, aes(x=name, y=value)) + 
  geom_bar(stat = "identity",
           color = "grey",
           fill = "lightblue") +
  
  coord_cartesian(ylim = c(min(acpf_cw_temperature$xiEst[,]),max(acpf_cw_temperature$xiEst[,])),#min et max en fonction du min et du max général
                  xlim = c(1,nbmaxcp)) +
  labs(x = "Composantes principales",
       y = "Coefficient associé",
       title = paste("Scores estimés pour l'individu", selected_indiv, "sur", nbmaxcp, "composantes principales"))

```

essayer d'utiliser une autre fonction que layout()
vérifier si le flowlayout dans l'ui a une bonne syntaxe


```{r Graphe cumulative PVE}
library(tidyverse)
library(DynForest)
library(fdapace)
library(JM)
library(fda)

#test avec cw

data("CanadianWeather")
data<- CanadianWeather

acpf_data <- acpf(data, donnees = "dailyAv", variable = "Temperature.C", type="denseList")

#cumPVE
nb_CP = 4
PVE <- data.frame(value = acpf_data$cumFVE * 100, name = paste0("CP", seq(1, nb_CP)))
ggplot(PVE, aes(x=name, y=value)) + 
  geom_bar(stat = "identity",
           color = "grey",
           fill = "lightblue") +
  labs(x = "Composantes principales", y = "Pourcentage de variance cumulée")


```

```{r Test PVE Corentin}

acpf_data <- acpf(data, donnees = "dailyAv", variable = "Temperature.C", type="denseList", n)
PVEtest <- acpf_data$cumFVE

# charger et preparer les donnees
data(pbc2)
pbc_list <- split(pbc2, f = pbc2$id)
pbc_Ly <- lapply(pbc_list, function(x) return(x$albumin))
pbc_Lt <- lapply(pbc_list, function(x) return(x$time))

# fpca avec 20 composantes (le max autorisé par l'algo)
fpca_20 <- FPCA(pbc_Ly, pbc_Lt, list(dataType = "Sparse", methodSelectK = as.integer(20)))
fpca_20 <- FPCA(pbc2$serChol, pbc2$, list(dataType = "Sparse", methodSelectK = as.integer(20)))
fpca_20$lambda # les 20 valeurs propres qui correspondent aux 20 composantes demandees (tu remarques qu'on arrive très vite à des valeurs propres quasi nulles qui n'expliquent plus grand chose)
fpca_20$cumFVE # PVE cumulés
cumsum(fpca_20$lambda)/sum(fpca_20$lambda) # on recacule les PVE à la main en faisant la somme cumulée des vp sur la somme des vp et on retombe et sur cumFVE

# fpca avec 3 composantes
fpca_3 <- FPCA(pbc_Ly, pbc_Lt, list(dataType = "Sparse", methodSelectK = as.integer(3)))
fpca_3$lambda # les 3 valeurs propres qui correspondent aux 3 composantes demandees
fpca_3$cumFVE # PVE cumulés
cumsum(fpca_3$lambda)/sum(fpca_3$lambda) # l'algo ne calcule pas les PVE qu'avec ces 3 composantes
cumsum(fpca_3$lambda)/sum(fpca_20$lambda) # mais il les calcule en utilisant toutes les valeurs propres (en tout cas le max autorisé par l'algo, 20 ici)
```

















